{"version":3,"file":"index.js","sources":["../src/index.js"],"sourcesContent":["/**\n * @export\n * @class AddressAutocomplete\n * @author Deric Cain <deric.cain@gmail.com>\n * @contributor Braunson Yager <braunson@gmail.com>\n * @contributor Jonathan Sardo <sardoj@gmail.com>\n */\nexport default class AddressAutocomplete {\n  /**\n   * Creates an instance of AddressAutocomplete.\n   * @param {string} element - This should be in the form of either '.address' or '#address'\n   * @param {object|function} optionsOrCallback - This object contains options to add to the API call or a callback\n   * @param {function|null} callback - This callback will have the result passed as the first param\n   * @throws Error - If we don't have a valid element\n   * @memberof AddressAutocomplete\n   */\n  constructor(element, optionsOrCallback, callback = null) {\n    // Can take element as '.class-name' or '#id-name'\n    this.element = document.querySelector(element);\n\n    // If we do not find the element, then we need to throw an error\n    if (!this.element) {\n      throw new Error(\n        \"The element you specified is not a valid element. You should attach an input using a class '.some-class' or an ID '#some-id'.\"\n      );\n    }\n\n    // Default options\n    const defaultOptions = {\n      types: ['geocode'],\n    };\n\n    if (typeof optionsOrCallback === 'function') {\n      // Compatible with previous versions\n      // Second parameter is a callback function\n      this.callback = optionsOrCallback;\n\n      // There is not extra options\n      this.options = defaultOptions;\n    } else if (typeof optionsOrCallback === 'object') {\n      // Second parameter is an options list\n      this.options = Object.assign({}, defaultOptions, optionsOrCallback);\n\n      // Third parameter is a callback function\n      this.callback = callback;\n    } else {\n      throw new Error(\n        'To be able to use extra options, the type of the second parameter must be \"object\" and the type of the third parameter must be \"function\".'\n      );\n    }\n\n    // We are binding the context of 'this' to this class instance\n    this.extractAddress = this.extractAddress.bind(this);\n    this.getUsersLocation = this.getUsersLocation.bind(this);\n    this.handle();\n  }\n\n  /**\n   * This takes care of make everything happen\n   *\n   * @memberof AddressAutocomplete\n   */\n  handle() {\n    // When the document is ready, we need to fire everything off.\n    document.addEventListener('readystatechange', () => {\n      this.initializeAutocomplete();\n      this.element.addEventListener('focus', this.getUsersLocation);\n    });\n  }\n\n  /**\n   * This method takes care of getting the autocomplete up and running with custom options\n   *\n   * @memberof AddressAutocomplete\n   */\n  initializeAutocomplete() {\n    this.autocomplete = new google.maps.places.Autocomplete(\n      this.element,\n      this.options\n    );\n    this.autocomplete.addListener('place_changed', this.extractAddress);\n  }\n\n  /**\n   * Here, we are taking care of getting the address from the results.\n   *\n   * @memberof AddressAutocomplete\n   */\n  extractAddress() {\n    const componentForm = {\n      street_number: 'short_name',\n      route: 'long_name',\n      locality: 'long_name',\n      administrative_area_level_1: 'short_name',\n      country: 'long_name',\n      postal_code: 'short_name',\n      postal_town: 'long_name'\n    };\n\n    const resultRaw = this.autocomplete.getPlace();\n    const {\n      address_components,\n      formatted_address,\n      geometry: { location: { lat, lng } },\n    } = resultRaw;\n    const addressObject = {\n      streetNumber: '',\n      streetName: '',\n      cityName: '',\n      stateAbbr: '',\n      zipCode: '',\n      coordinates: { lat: lat(), lng: lng() },\n    };\n\n    // Need to loop over the results and create a friendly object\n    for (let i = 0; i < address_components.length; i++) {\n      const addressType = address_components[i].types[0];\n      if (componentForm[addressType]) {\n        switch (addressType) {\n          case 'street_number':\n            addressObject.streetNumber = address_components[i].long_name;\n            break;\n          case 'route':\n            addressObject.streetName = address_components[i].long_name;\n            break;\n          case 'locality':\n          case 'postal_town':\n            addressObject.cityName = address_components[i].long_name;\n            break;\n          case 'administrative_area_level_1':\n            addressObject.stateAbbr = address_components[i].short_name;\n            addressObject.state = address_components[i].long_name;\n            break;\n          case 'postal_code':\n            addressObject.zipCode = address_components[i].long_name;\n            break;\n          case 'country':\n            addressObject.countryAbbr = address_components[i].short_name;\n            addressObject.country = address_components[i].long_name;\n            break;\n          default:\n            break;\n        }\n      }\n    }\n\n    const resultFormatted = Object.assign({}, addressObject, {\n      formattedAddress: formatted_address,\n    });\n\n    // This is where we check for the callback and then call it, passing our resutls\n    this.callback(resultFormatted, resultRaw);\n  }\n\n  /**\n   * This will help us narrow down the results of the autocomplete to a user's location\n   *\n   * @memberof AddressAutocomplete\n   */\n  getUsersLocation() {\n    // Using feature detection to make sure the browser supports geolocation\n    if (navigator.geolocation) {\n      navigator.geolocation.getCurrentPosition(position => {\n        const geolocation = {\n          lat: position.coords.latitude,\n          lng: position.coords.longitude,\n        };\n        const circle = new google.maps.Circle({\n          center: geolocation,\n          radius: position.coords.accuracy,\n        });\n        this.autocomplete.setBounds(circle.getBounds());\n      });\n    }\n  }\n}\n"],"names":["AddressAutocomplete","element","optionsOrCallback","callback","document","querySelector","this","Error","defaultOptions","options","Object","assign","extractAddress","bind","getUsersLocation","handle","addEventListener","initializeAutocomplete","_this","autocomplete","google","maps","places","Autocomplete","addListener","componentForm","resultRaw","getPlace","address_components","formatted_address","geometry","location","lat","lng","addressObject","i","length","addressType","types","streetNumber","long_name","streetName","cityName","stateAbbr","short_name","state","zipCode","countryAbbr","country","resultFormatted","navigator","geolocation","getCurrentPosition","position","coords","latitude","longitude","circle","Circle","accuracy","setBounds","getBounds"],"mappings":"6mDAOqBA,0CASPC,EAASC,OAAmBC,yDAAW,oCAE5CF,QAAUG,SAASC,cAAcJ,IAGjCK,KAAKL,cACF,IAAIM,MACR,qIAKEC,UACI,eAGuB,mBAAtBN,OAGJC,SAAWD,OAGXO,QAAUD,MACV,CAAA,GAAiC,qBAAtBN,sBAAAA,UAOV,IAAIK,MACR,mJANGE,QAAUC,OAAOC,UAAWH,EAAgBN,QAG5CC,SAAWA,OAQbS,eAAiBN,KAAKM,eAAeC,KAAKP,WAC1CQ,iBAAmBR,KAAKQ,iBAAiBD,KAAKP,WAC9CS,kFAUIC,iBAAiB,mBAAoB,aACvCC,2BACAhB,QAAQe,iBAAiB,QAASE,EAAKJ,0EAUzCK,aAAe,IAAIC,OAAOC,KAAKC,OAAOC,aACzCjB,KAAKL,QACLK,KAAKG,cAEFU,aAAaK,YAAY,gBAAiBlB,KAAKM,6DAmC/C,IA1BCa,iBACW,mBACR,qBACG,wCACmB,qBACpB,wBACI,yBACA,aAGTC,EAAYpB,KAAKa,aAAaQ,WAElCC,EAGEF,EAHFE,mBACAC,EAEEH,EAFFG,oBAEEH,EADFI,SAAYC,SAAYC,IAAAA,IAAKC,IAAAA,IAEzBC,gBACU,cACF,YACF,aACC,WACF,gBACMF,IAAKA,IAAOC,IAAKA,MAIzBE,EAAI,EAAGA,EAAIP,EAAmBQ,OAAQD,IAAK,KAC5CE,EAAcT,EAAmBO,GAAGG,MAAM,MAC5Cb,EAAcY,UACRA,OACD,kBACWE,aAAeX,EAAmBO,GAAGK,oBAEhD,UACWC,WAAab,EAAmBO,GAAGK,oBAE9C,eACA,gBACWE,SAAWd,EAAmBO,GAAGK,oBAE5C,gCACWG,UAAYf,EAAmBO,GAAGS,aAClCC,MAAQjB,EAAmBO,GAAGK,oBAEzC,gBACWM,QAAUlB,EAAmBO,GAAGK,oBAE3C,YACWO,YAAcnB,EAAmBO,GAAGS,aACpCI,QAAUpB,EAAmBO,GAAGK,eAQhDS,EAAkBvC,OAAOC,UAAWuB,oBACtBL,SAIf1B,SAAS8C,EAAiBvB,yDAU3BwB,UAAUC,uBACFA,YAAYC,mBAAmB,gBACjCD,OACCE,EAASC,OAAOC,aAChBF,EAASC,OAAOE,WAEjBC,EAAS,IAAIrC,OAAOC,KAAKqC,eACrBP,SACAE,EAASC,OAAOK,aAErBxC,aAAayC,UAAUH,EAAOI"}